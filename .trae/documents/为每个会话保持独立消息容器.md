## 目标

* 每个 `currentId` 保持一个独立、常驻的消息容器；仅激活的容器显示，其他容器隐藏但不卸载。

* 初始化仅创建并显示当前激活会话的容器；切换历史时若容器不存在则懒加载并创建；若已存在则仅显示对应容器。

## 改动范围

* 主改动文件：`src/views/sidebar/chat.tsx`

* 现有消息列表组件：`src/views/sidebar/component/message-list/message-list.tsx` 保持不变（其滚动位置已通过 `currentId` 做键控缓存）。

## 数据结构调整

* 在 `chat.tsx` 内新增一个会话状态表：

  * `sessions: Record<string, { messages: Message[]; selectedNotes: NoteContext[] }>`

  * 以 `currentId` 作为键，存储每个会话的消息与所选笔记上下文。

* 现有的 `messages` 与 `selectedNotes` 的单一状态改为读取/写入 `sessions[currentId]`。

* `messagesChanged` 仍作为全局标记，但在切换会话时重置为 `false`。

## 关键逻辑修改

* 替换 `useEffect(currentId)` 加载逻辑（`chat.tsx:58-93`）：

  * 若 `!currentId`：清空初始化标记，返回。

  * 若 `sessions[currentId]` 已存在：仅设置 `isInitializing=false` 并显示该容器。

  * 若不存在：

    * 设置 `isInitializing=true`；

    * 从存储加载该 `currentId` 的历史消息与笔记引用（沿用现有 `getHistoryItemById` 与 `fileStorageService.convertToNoteContexts`）；

    * 写入 `sessions[currentId] = { messages, selectedNotes }`；

    * `isInitializing=false`。

* 保存逻辑 `useEffect` 改为基于当前会话：从 `sessions[currentId]` 读取 `messages` 与 `selectedNotes`，保持与原来的 `upsertHistoryItem` 行为一致。

* 发送与重生成逻辑：

  * `handleSend` 与 `handleRegenerateMessage` 改为操作 `sessions[currentId].messages`。

  * `getNotePrompts` 读取 `sessions[currentId].selectedNotes`。

  * 其余调用（如 `sendChatMessage`、`cancelToken`）维持不变。

* 文件选择相关：

